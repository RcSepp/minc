

// >>> Not very useful, but working


/*exprdef<int> mytype {
	return LLVMBuildAlloca(LLVMInt32Type(), "");
}
return mytype;*/


// >>> Some experiments with addToScope(). This raises `mytype` is not a type inside DEFINE_MYTYPE2


/*stmtdef DEFINE_MYTYPE {
	addToScope(parentBlock, mytype, int, LLVMInt32Type());
}
DEFINE_MYTYPE;

stmtdef DEFINE_MYTYPE2 {
	addToScope(parentBlock, mytype2, mytype, LLVMInt32Type());
}
DEFINE_MYTYPE2;*/


// >>> TYPE SYSTEM V1


struct MyType {
	LLVMTypeRef type;
	int align;
};

typedef<mySuperType> myType {
	return MyType{LLVMInt32Type(), 4};
	// This should be stored as: scope["myType"] = Variable{type: mySuperType, value: `MyType{LLVMInt32Type(), 4}`}
	// The problem: This infers that both myType and mySuperType are LLVMValueRef's
	//     -> How do we do static type checking with LLVMValueRef's?!?
}

stmtdef $<mySuperType> $I {
	LLVMValueRef foo = LLVMBuildAlloca($0.type, "");
	LLVMSetAlignment(foo, $0.align);
	addToScope(parentBlock, $1, mySuperType, foo);
}

return mytype;


// >>> TYPE SYSTEM V2


struct MyType {
	LLVMTypeRef type;
	int align;
};
mySuperType = MySuperType{}
myType = MyType{LLVMInt32Type(), 4}

// No need for castdef
// Use exprdef:
exprdef<mySuperType> $<myType> {
	return $0;
}

// No need for typedef
// Type hierarchy implemented through casting
// * This works with simple bit-casts (`return $0`) and arbitrarily complex tasks
// * Two way casting (i.e. int <-> float) no problem

stmtdef $<mySuperType> $I {
	LLVMValueRef foo = LLVMBuildAlloca($0.type, "");
	LLVMSetAlignment(foo, $0.align);
	addToScope(parentBlock, $1, $0, foo); // old
	symdef<$0> $1 = foo; // new
}

return mytype;

// Additions:

// Change BlockExprAST::scope<void*, LLVMValue*> to BlockExprAST::symbolTable<LLVMValue*, LLVMValue*>
// Rename BlockExprAST::addToScope() to BlockExprAST::defineSymbol()
// Rename BlockExprAST::lookupScope() to BlockExprAST::lookupSymbol()
// Implement addToScope(parentBlock, NAME, TYPE, VALUE) as symdef<TYPE> NAME = VALUE or symdef<TYPE> NAME VALUE