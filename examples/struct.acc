import <builtin.acc>;

stmtdef string $I {
	LLVMValueRef foo = LLVMBuildAlloca(LLVMPointerType(LLVMInt8Type(), 0), "");
	LLVMSetAlignment(foo, 8);
	addToScope(parentBlock, $0, int, foo);
}
stmtdef string $I = $E {
	LLVMValueRef foo = LLVMBuildAlloca(LLVMPointerType(LLVMInt8Type(), 0), "");
	LLVMSetAlignment(LLVMBuildStore(
		codegen($1, parentBlock),
		foo
	), 8);
	addToScope(parentBlock, $0, int, foo);
}

stmtdef class $I $B {
	string name;
	name = $0.name;
	LLVMTypeRef structType = LLVMStructCreateNamed(LLVMGetGlobalContext(), name);

	LLVMTypeRef elementTypes[2];
	elementTypes[0] = LLVMInt32Type();
	elementTypes[1] = LLVMInt32Type();
	LLVMStructSetBody(structType, elementTypes, 2, 0);

	int i = 456;

	stmtdef2 parentBlock Shape $I { //TODO: Currently, $0 can't be used in the statement template.
	// Think about how to implement dynamic templates!

		printf("<%i>\n", i); //TODO: This prints garbage, because the line `int i = 456;`
		// was executed from line `class Shape { ... }`, while this line is executed from line `Shape rect;`.
		// `i` doesn't exist in this scope!

// For now just allocate an int
LLVMValueRef foo = LLVMBuildAlloca(LLVMInt32Type(), "");
LLVMSetAlignment(foo, 4);
addToScope(parentBlock, $0, int, foo);

		//addToScope(parentBlock, $0, LLVMValueRef, LLVMBuildAlloca(LLVMPointerType(structType, 0), ""));
	}
}

class Shape {
	public 123;
}

Shape rect;
rect = 123;
return rect;
