/* ---------------------------------------------------------------------------*\
Name: Return statement
Template: return $E
Depends on: none
\* ---------------------------------------------------------------------------*/
stmtdef return $E<int> {
	LLVMBuildRet($0.codegen(parentBlock));
}

/* ---------------------------------------------------------------------------*\
Cast: LiteralExprAST to ExprAST
Depends on: return $E
\* ---------------------------------------------------------------------------*/
inhtdef<ExprAST> $E<LiteralExprAST> {
	return LLVMBuildBitCast(
		$0.codegen(parentBlock),
		LLVMPointerType(LLVMGetTypeByName("class.ExprAST"), 0),
		""
	);
}

/* ---------------------------------------------------------------------------*\
Cast: IdExprAST to ExprAST
Depends on: return $E
\* ---------------------------------------------------------------------------*/
inhtdef<ExprAST> $E<IdExprAST> {
	return LLVMBuildBitCast(
		$0.codegen(parentBlock),
		LLVMPointerType(LLVMGetTypeByName("class.ExprAST"), 0),
		""
	);
}

/* ---------------------------------------------------------------------------*\
Cast: BlockExprAST to ExprAST
Depends on: return $E
\* ---------------------------------------------------------------------------*/
inhtdef<ExprAST> $E<BlockExprAST> {
	return LLVMBuildBitCast(
		$0.codegen(parentBlock),
		LLVMPointerType(LLVMGetTypeByName("class.ExprAST"), 0),
		""
	);
}

/* ---------------------------------------------------------------------------*\
Name: Context-free block statement
Template: $B
Depends on: none
\* ---------------------------------------------------------------------------*/
stmtdef $B {
	$0.codegen(parentBlock);
}

/* ---------------------------------------------------------------------------*\
Name: Simplified variable assignment
Template: $I = $E
Depends on: return $E
Notes: This expression does not check for errors and it does not return $E
\* ---------------------------------------------------------------------------*/
exprdef<void> $I = $E {
	LLVMBuildStore($1.codegen(parentBlock), LookupScope(parentBlock, $0));
	return LLVMConstNull(LLVMVoidType());
}


/* ---------------------------------------------------------------------------*\
|                                                                              |
|                                  LLVM TYPES                                  |
|                                                                              |
\* ---------------------------------------------------------------------------*/


/* ---------------------------------------------------------------------------*\
Name: LLVMValueRef declaration
Template: LLVMValueRef $I
Depends on: none
\* ---------------------------------------------------------------------------*/
stmtdef LLVMValueRef $I {
	addToScope(parentBlock, $0, LLVMValueRef, LLVMBuildAlloca(LLVMPointerType(LLVMGetTypeByName("struct.LLVMOpaqueValue"), 0), ""));
}

/* ---------------------------------------------------------------------------*\
Name: LLVMValueRef declaration with initialization
Template: LLVMValueRef $I = $E<LLVMValueRef>
Depends on: LLVMValueRef $I
\* ---------------------------------------------------------------------------*/
stmtdef LLVMValueRef $I = $E<LLVMValueRef> {
	LLVMValueRef foo;
	foo = LLVMBuildAlloca(LLVMPointerType(LLVMGetTypeByName("struct.LLVMOpaqueValue"), 0), "");
	LLVMBuildStore($1.codegen(parentBlock), foo);
	addToScope(parentBlock, $0, LLVMValueRef, foo);
}

stmtdef LLVMValueRef $I[$E<int>] {
	// Fixed size array:
	/*addToScope(
		parentBlock,
		$0,
		LLVMValueRef,
		LLVMBuildAlloca(
			LLVMArrayType(LLVMPointerType(LLVMGetTypeByName("struct.LLVMOpaqueValue"), 0), atoi($1.value)),
			""
		)
	);*/

	// Dynamic array:
	LLVMValueRef array = LLVMBuildArrayAlloca(
		LLVMPointerType(LLVMGetTypeByName("struct.LLVMOpaqueValue"), 0),
		$1.codegen(parentBlock),
		""
	);
	LLVMValueRef arrayptr = LLVMBuildAlloca(LLVMPointerType(LLVMPointerType(LLVMGetTypeByName("struct.LLVMOpaqueValue"), 0), 0), "");
	LLVMBuildStore(
		array,
		arrayptr
	);
	addToScope(
		parentBlock,
		$0,
		LLVMValueRefPtr,
		arrayptr
	);
}

//TODO: Generalize to `exprdef<gettype($2, parentBlock)> $E[$E<int>] = $E {`
exprdef<LLVMValueRef> $E<LLVMValueRefPtr>[$E<int>] = $E<LLVMValueRef> {
	LLVMValueRef var = $0.codegen(parentBlock);
	LLVMValueRef idx = $1.codegen(parentBlock);

	LLVMValueRef gep = LLVMBuildInBoundsGEP1(var, idx, "");

	LLVMValueRef expr = $2.codegen(parentBlock);
	LLVMBuildStore(
		expr,
		gep
	);
	return expr;
}

//TODO: Untested
exprdef<LLVMValueRef> $E<LLVMValueRefPtr>[$E<int>] {
	LLVMValueRef var = $0.codegen(parentBlock);
	LLVMValueRef idx = $1.codegen(parentBlock);

	LLVMValueRef gep = LLVMBuildInBoundsGEP1(var, idx, "");
	LLVMValueRef val = LLVMBuildLoad(gep, "");
	LLVMSetAlignment(val, 8);
	return val;
}

/* ---------------------------------------------------------------------------*\
Cast: LLVMValueRef to bool
Depends on: return $E
\* ---------------------------------------------------------------------------*/
castdef<bool> $E<LLVMValueRef> { return LLVMBuildIsNotNull($0.codegen(parentBlock), ""); }

/* ---------------------------------------------------------------------------*\
Name: LLVMBasicBlockRef declaration
Template: LLVMBasicBlockRef $I
Depends on: none
\* ---------------------------------------------------------------------------*/
stmtdef LLVMBasicBlockRef $I {
	addToScope(parentBlock, $0, LLVMBasicBlockRef, LLVMBuildAlloca(LLVMPointerType(LLVMGetTypeByName("struct.LLVMOpaqueBasicBlock"), 0), ""));
}

/* ---------------------------------------------------------------------------*\
Name: LLVMBasicBlockRef declaration with initialization
Template: LLVMBasicBlockRef $I = $E<LLVMBasicBlockRef>
Depends on: LLVMBasicBlockRef $I
\* ---------------------------------------------------------------------------*/
stmtdef LLVMBasicBlockRef $I = $E<LLVMBasicBlockRef> {
	LLVMValueRef foo = LLVMBuildAlloca(LLVMPointerType(LLVMGetTypeByName("struct.LLVMOpaqueBasicBlock"), 0), "");
	LLVMBuildStore($1.codegen(parentBlock), foo);
	addToScope(parentBlock, $0, LLVMBasicBlockRef, foo);
}

/* ---------------------------------------------------------------------------*\
Name: LLVMTypeRef declaration
Template: LLVMTypeRef $I
Depends on: none
\* ---------------------------------------------------------------------------*/
stmtdef LLVMTypeRef $I {
	addToScope(parentBlock, $0, LLVMTypeRef, LLVMBuildAlloca(LLVMPointerType(LLVMGetTypeByName("struct.LLVMOpaqueType"), 0), ""));
}

/* ---------------------------------------------------------------------------*\
Name: LLVMTypeRef declaration with initialization
Template: LLVMTypeRef $I = $E<LLVMTypeRef>
Depends on: LLVMTypeRef $I
\* ---------------------------------------------------------------------------*/
stmtdef LLVMTypeRef $I = $E<LLVMTypeRef> {
	LLVMValueRef foo = LLVMBuildAlloca(LLVMPointerType(LLVMGetTypeByName("struct.LLVMOpaqueType"), 0), "");
	LLVMBuildStore($1.codegen(parentBlock), foo);
	addToScope(parentBlock, $0, LLVMTypeRef, foo);
}

stmtdef LLVMTypeRef $I[$E<int>] {
	// Fixed size array:
	/*addToScope(
		parentBlock,
		$0,
		LLVMTypeRef,
		LLVMBuildAlloca(
			LLVMArrayType(LLVMPointerType(LLVMGetTypeByName("struct.LLVMOpaqueType"), 0), atoi($1.value)),
			""
		)
	);*/

	// Dynamic array:
	LLVMValueRef array = LLVMBuildArrayAlloca(
		LLVMPointerType(LLVMGetTypeByName("struct.LLVMOpaqueType"), 0),
		$1.codegen(parentBlock),
		""
	);
	LLVMValueRef arrayptr = LLVMBuildAlloca(LLVMPointerType(LLVMPointerType(LLVMGetTypeByName("struct.LLVMOpaqueType"), 0), 0), "");
	LLVMBuildStore(
		array,
		arrayptr
	);
	addToScope(
		parentBlock,
		$0,
		LLVMTypeRefPtr,
		arrayptr
	);
}

exprdef<LLVMTypeRef> $E<LLVMTypeRefPtr>[$E<int>] = $E<LLVMTypeRef> {
	LLVMValueRef var = $0.codegen(parentBlock);
	LLVMValueRef idx = $1.codegen(parentBlock);

	LLVMValueRef gep = LLVMBuildInBoundsGEP1(var, idx, "");

	LLVMValueRef expr = $2.codegen(parentBlock);
	LLVMBuildStore(
		expr,
		gep
	);
	return expr;
}

/* ---------------------------------------------------------------------------*\
Cast: LLVMMetadataRef to bool
Depends on: return $E
\* ---------------------------------------------------------------------------*/
castdef<bool> $E<LLVMMetadataRef> { return LLVMBuildIsNotNull($0.codegen(parentBlock), ""); }

/* ---------------------------------------------------------------------------*\
Name: BuiltinType declaration
Template: BuiltinType $I
\* ---------------------------------------------------------------------------*/
stmtdef BuiltinType $I {
	LLVMValueRef storage = LLVMBuildAlloca(LLVMPointerType(LLVMGetTypeByName("BuiltinType"), 0), "");
	LLVMSetAlignment(storage, 8);
	addToScope(parentBlock, $0, BuiltinType, storage);
}

/* ---------------------------------------------------------------------------*\
Name: BuiltinType declaration with initialization
Template: BuiltinType $I = $E<BuiltinType>
\* ---------------------------------------------------------------------------*/
stmtdef BuiltinType $I = $E<BuiltinType> {
	LLVMValueRef storage = LLVMBuildAlloca(LLVMPointerType(LLVMGetTypeByName("BuiltinType"), 0), "");
	LLVMSetAlignment(storage, 8);
	LLVMBuildStore($1.codegen(parentBlock), storage);
	addToScope(parentBlock, $0, BuiltinType, storage);
}

exprdef<LLVMTypeRef> $E<BuiltinType>.llvmtype {
	return LLVMBuildLoad(LLVMBuildStructGEP($0.codegen(parentBlock), 2, "gep"), "llvmtype");
}

exprdef<int> $E<BuiltinType>.align {
	return LLVMBuildLoad(LLVMBuildStructGEP($0.codegen(parentBlock), 3, "gep"), "align");
}

exprdef<int> $E<BuiltinType>.encoding {
	return LLVMBuildLoad(LLVMBuildStructGEP($0.codegen(parentBlock), 4, "gep"), "encoding");
}

exprdef<long> $E<BuiltinType>.numbits {
	return LLVMBuildLoad(LLVMBuildStructGEP($0.codegen(parentBlock), 5, "gep"), "numbits");
}

/* ---------------------------------------------------------------------------*\
Name: Simplified variable declaration
Template: $E<BuiltinType> $I
Notes: This statement does not define debug symbols
\* ---------------------------------------------------------------------------*/
stmtdef $E<BuiltinType> $I {
	BuiltinType type = getconst($0, parentBlock);
	LLVMValueRef storage = LLVMBuildAlloca(type.llvmtype, "");
	LLVMSetAlignment(storage, type.align);
	addToScope(parentBlock, $1, type, storage);
}

/* ---------------------------------------------------------------------------*\
Name: Simplified variable declaration with initialization
Template: $E<BuiltinType> $I = $E
Notes: This statement does not define debug symbols and it does not cast the expression type
\* ---------------------------------------------------------------------------*/
stmtdef $E<BuiltinType> $I = $E {
	BuiltinType type = getconst($0, parentBlock);
	LLVMValueRef storage = LLVMBuildAlloca(type.llvmtype, "");
	LLVMSetAlignment(storage, type.align);
	LLVMBuildStore($2.codegen(parentBlock), storage);
	addToScope(parentBlock, $1, type, storage);
}

/* ---------------------------------------------------------------------------*\
Name: BaseType declaration
Template: BaseType $I
Depends on: none
\* ---------------------------------------------------------------------------*/
stmtdef BaseType $I {
	addToScope(parentBlock, $0, BaseType, LLVMBuildAlloca(LLVMPointerType(LLVMGetTypeByName("BaseType"), 0), ""));
}

/* ---------------------------------------------------------------------------*\
Name: BaseType declaration with initialization
Template: BaseType $I = $E
TODO: Should be $I = $E<BaseType>
Depends on: BaseType $I
\* ---------------------------------------------------------------------------*/
stmtdef BaseType $I = $E<BaseType> {
	LLVMValueRef foo = LLVMBuildAlloca(LLVMPointerType(LLVMGetTypeByName("BaseType"), 0), "");
	LLVMBuildStore($1.codegen(parentBlock), foo);
	addToScope(parentBlock, $0, BaseType, foo);
}


/* ---------------------------------------------------------------------------*\
|                                                                              |
|                                  AST TYPES                                   |
|                                                                              |
\* ---------------------------------------------------------------------------*/


/* ---------------------------------------------------------------------------*\
Name: ExprAST declaration
Template: ExprAST $I
Depends on: none
\* ---------------------------------------------------------------------------*/
stmtdef ExprAST $I {
	addToScope(parentBlock, $0, ExprAST, LLVMBuildAlloca(LLVMPointerType(LLVMGetTypeByName("class.ExprAST"), 0), ""));
}

/* ---------------------------------------------------------------------------*\
Name: ExprAST declaration with initialization
Template: ExprAST $I = $E
Depends on: ExprAST $I
\* ---------------------------------------------------------------------------*/
stmtdef ExprAST $I = $E<ExprAST> {
	LLVMValueRef foo = LLVMBuildAlloca(LLVMPointerType(LLVMGetTypeByName("class.ExprAST"), 0), "");
	LLVMBuildStore($1.codegen(parentBlock), foo);
	addToScope(parentBlock, $0, ExprAST, foo);
}

/* ---------------------------------------------------------------------------*\
Name: LiteralExprAST declaration
Template: LiteralExprAST $I
Depends on: none
\* ---------------------------------------------------------------------------*/
stmtdef LiteralExprAST $I {
	addToScope(parentBlock, $0, LiteralExprAST, LLVMBuildAlloca(LLVMPointerType(LLVMGetTypeByName("class.LiteralExprAST"), 0), ""));
}

/* ---------------------------------------------------------------------------*\
Name: LiteralExprAST declaration with initialization
Template: LiteralExprAST $I = $E
Depends on: LiteralExprAST $I
\* ---------------------------------------------------------------------------*/
stmtdef LiteralExprAST $I = $E<LiteralExprAST> {
	LLVMValueRef foo = LLVMBuildAlloca(LLVMPointerType(LLVMGetTypeByName("class.LiteralExprAST"), 0), "");
	LLVMBuildStore($1.codegen(parentBlock), foo);
	addToScope(parentBlock, $0, LiteralExprAST, foo);
}

/* ---------------------------------------------------------------------------*\
Name: IdExprAST declaration
Template: IdExprAST $I
Depends on: none
\* ---------------------------------------------------------------------------*/
stmtdef IdExprAST $I {
	addToScope(parentBlock, $0, IdExprAST, LLVMBuildAlloca(LLVMPointerType(LLVMGetTypeByName("class.IdExprAST"), 0), ""));
}

/* ---------------------------------------------------------------------------*\
Name: IdExprAST declaration with initialization
Template: IdExprAST $I = $E
Depends on: IdExprAST $I
\* ---------------------------------------------------------------------------*/
stmtdef IdExprAST $I = $E<IdExprAST> {
	LLVMValueRef foo = LLVMBuildAlloca(LLVMPointerType(LLVMGetTypeByName("class.IdExprAST"), 0), "");
	LLVMBuildStore($1.codegen(parentBlock), foo);
	addToScope(parentBlock, $0, IdExprAST, foo);
}

/* ---------------------------------------------------------------------------*\
Name: BlockExprAST declaration
Template: BlockExprAST $I
Depends on: none
\* ---------------------------------------------------------------------------*/
stmtdef BlockExprAST $I {
	addToScope(parentBlock, $0, BlockExprAST, LLVMBuildAlloca(LLVMPointerType(LLVMGetTypeByName("class.BlockExprAST"), 0), ""));
}

/* ---------------------------------------------------------------------------*\
Name: BlockExprAST declaration with initialization
Template: BlockExprAST $I = $E
Depends on: BlockExprAST $I
\* ---------------------------------------------------------------------------*/
stmtdef BlockExprAST $I = $E<BlockExprAST> {
	LLVMValueRef foo = LLVMBuildAlloca(LLVMPointerType(LLVMGetTypeByName("class.BlockExprAST"), 0), "");
	LLVMBuildStore($1.codegen(parentBlock), foo);
	addToScope(parentBlock, $0, BlockExprAST, foo);
}

exprdef<Location> $E<ExprAST>.loc {
	LLVMValueRef args[1];
	args[0] = $0.codegen(parentBlock);
	return LLVMBuildCall(getExprLoc, args, 1, "");
}

exprdef<int> $E<ExprListAST>.size {
	LLVMValueRef args[1];
	args[0] = $0.codegen(parentBlock);
	return LLVMBuildTrunc(
		LLVMBuildCall(getExprListASTSize, args, 1, ""),
		LLVMInt32Type(),
		""
	);
}

exprdef<string> $E<LiteralExprAST>.value {
	LLVMValueRef args[1];
	args[0] = $0.codegen(parentBlock);
	return LLVMBuildCall(getLiteralExprASTValue, args, 1, "");
}

exprdef<string> $E<IdExprAST>.name {
	LLVMValueRef args[1];
	args[0] = $0.codegen(parentBlock);
	return LLVMBuildCall(getIdExprASTName, args, 1, "");
}

exprdef<BlockExprAST> $E<BlockExprAST>.parent {
	LLVMValueRef args[1];
	args[0] = $0.codegen(parentBlock);
	return LLVMBuildCall(getBlockExprASTParent, args, 1, "");
}

exprdef<BlockExprAST> $E<BlockExprAST>.parent = $E<BlockExprAST> {
	LLVMValueRef args[2];
	args[0] = $0.codegen(parentBlock);
	args[1] = $1.codegen(parentBlock);
	return LLVMBuildCall(setBlockExprASTParent, args, 2, "");
}

/* ---------------------------------------------------------------------------*\
Cast: ExprAST to bool
Depends on: return $E
\* ---------------------------------------------------------------------------*/
castdef<bool> $E<ExprAST> { return LLVMBuildIsNotNull($0.codegen(parentBlock), ""); }


/* ---------------------------------------------------------------------------*\
|                                                                              |
|                                NUMERIC TYPES                                 |
|                                                                              |
\* ---------------------------------------------------------------------------*/


/* ---------------------------------------------------------------------------*\
Name: Logical NOT
Template: !$E<bool>
Depends on: return $E
\* ---------------------------------------------------------------------------*/
exprdef<bool> !$E<bool> {
	return LLVMBuildNot($0.codegen(parentBlock), "not");
}

/* ---------------------------------------------------------------------------*\
Name: Logical AND
Template: $E<bool> && $E<bool>
Depends on: return $E
\* ---------------------------------------------------------------------------*/
exprdef<bool> $E<bool> && $E<bool> {
	return LLVMBuildAnd($0.codegen(parentBlock), $1.codegen(parentBlock), "and");
}

/* ---------------------------------------------------------------------------*\
Name: Logical OR
Template: $E<bool> || $E<bool>
Depends on: return $E
\* ---------------------------------------------------------------------------*/
exprdef<bool> $E<bool> || $E<bool> {
	return LLVMBuildOr($0.codegen(parentBlock), $1.codegen(parentBlock), "or");
}

exprdef<bool> $E<bool> == $E<bool> {
	return LLVMBuildICmp(LLVMIntEQ, $0.codegen(parentBlock), $1.codegen(parentBlock), "cmp");
}

exprdef<bool> $E<bool> != $E<bool> {
	return LLVMBuildICmp(LLVMIntNE, $0.codegen(parentBlock), $1.codegen(parentBlock), "cmp");
}

/* ---------------------------------------------------------------------------*\
Name: Integer addition
Template: $E<int> + $E<int>
Depends on: return $E
\* ---------------------------------------------------------------------------*/
// exprdef<int> $E<int> + $E<int> {
// 	return LLVMBuildAdd($0.codegen(parentBlock), $1.codegen(parentBlock), "add");
// }
exprdef<int> $E<int> + $E<int> {
	return LLVMBuildAdd($0.codegen(parentBlock), $1.codegen(parentBlock), "add");
}

/* ---------------------------------------------------------------------------*\
Name: Integer subtraction
Template: $E<int> - $E<int>
Depends on: return $E
\* ---------------------------------------------------------------------------*/
exprdef<int> $E<int> - $E<int> {
	return LLVMBuildSub($0.codegen(parentBlock), $1.codegen(parentBlock), "sub");
}

/* ---------------------------------------------------------------------------*\
Name: Integer multiplication
Template: $E<int> * $E<int>
Depends on: return $E
\* ---------------------------------------------------------------------------*/
exprdef<int> $E<int> * $E<int> {
	return LLVMBuildMul($0.codegen(parentBlock), $1.codegen(parentBlock), "mul");
}

/* ---------------------------------------------------------------------------*\
Name: Integer division
Template: $E<int> / $E<int>
Depends on: return $E
\* ---------------------------------------------------------------------------*/
exprdef<int> $E<int> / $E<int> {
	return LLVMBuildSDiv($0.codegen(parentBlock), $1.codegen(parentBlock), "div");
}

exprdef<bool> $E<int> == $E<int> {
	return LLVMBuildICmp(LLVMIntEQ, $0.codegen(parentBlock), $1.codegen(parentBlock), "cmp");
}

exprdef<bool> $E<int> != $E<int> {
	return LLVMBuildICmp(LLVMIntNE, $0.codegen(parentBlock), $1.codegen(parentBlock), "cmp");
}

/* ---------------------------------------------------------------------------*\
Name: Long bitwise AND
Template: $E<long> & $E<long>
Depends on: return $E
\* ---------------------------------------------------------------------------*/
exprdef<long> $E<long> & $E<long> {
	return LLVMBuildAnd($0.codegen(parentBlock), $1.codegen(parentBlock), "and");
}

exprdef<bool> $E<long> == $E<long> {
	return LLVMBuildICmp(LLVMIntEQ, $0.codegen(parentBlock), $1.codegen(parentBlock), "cmp");
}

exprdef<bool> $E<long> != $E<long> {
	return LLVMBuildICmp(LLVMIntNE, $0.codegen(parentBlock), $1.codegen(parentBlock), "cmp");
}

/* ---------------------------------------------------------------------------*\
Name: 64 bit float addition
Template: $E<double> + $E<double>
Depends on: return $E
\* ---------------------------------------------------------------------------*/
exprdef<double> $E<double> + $E<double> {
	return LLVMBuildFAdd($0.codegen(parentBlock), $1.codegen(parentBlock), "fadd");
}

/* ---------------------------------------------------------------------------*\
Name: 64 bit float multiplication
Template: $E<double> * $E<double>
Depends on: return $E
\* ---------------------------------------------------------------------------*/
exprdef<double> $E<double> * $E<double> {
	return LLVMBuildFMul($0.codegen(parentBlock), $1.codegen(parentBlock), "fmul");
}

exprdef<bool> $E<double> == $E<double> { //TODO: Untested
	return LLVMBuildFCmp(LLVMRealOEQ, $0.codegen(parentBlock), $1.codegen(parentBlock), "fcmp");
}

exprdef<bool> $E<double> != $E<double> { //TODO: Untested
	return LLVMBuildFCmp(LLVMRealONE, $0.codegen(parentBlock), $1.codegen(parentBlock), "fcmp");
}

/* ---------------------------------------------------------------------------*\
Cast: int to double
Depends on: return $E
\* ---------------------------------------------------------------------------*/
castdef<double> $E<int> {
	return LLVMBuildSIToFP(
		$0.codegen(parentBlock),
		LLVMDoubleType(),
		""
	);
}

/* ---------------------------------------------------------------------------*\
Cast: double to int
Depends on: return $E
\* ---------------------------------------------------------------------------*/
castdef<int> $E<double> {
	return LLVMBuildFPToSI(
		$0.codegen(parentBlock),
		LLVMInt32Type(),
		""
	);
}

/* ---------------------------------------------------------------------------*\
Cast: double to long
Depends on: return $E
\* ---------------------------------------------------------------------------*/
castdef<long> $E<double> {
	return LLVMBuildFPToSI(
		$0.codegen(parentBlock),
		LLVMInt64Type(),
		""
	);
}

/* ---------------------------------------------------------------------------*\
Cast: bool to int
Depends on: return $E
\* ---------------------------------------------------------------------------*/
castdef<int> $E<bool> {
	return LLVMBuildZExt(
		$0.codegen(parentBlock),
		LLVMInt32Type(),
		""
	);
}

/* ---------------------------------------------------------------------------*\
Cast: long to int
Depends on: return $E
\* ---------------------------------------------------------------------------*/
castdef<int> $E<long> {
	return LLVMBuildTrunc(
		$0.codegen(parentBlock),
		LLVMInt32Type(),
		""
	);
}

/* ---------------------------------------------------------------------------*\
Cast: int to bool
Depends on: return $E
\* ---------------------------------------------------------------------------*/
castdef<bool> $E<int> { return LLVMBuildIsNotNull($0.codegen(parentBlock), ""); }

/* ---------------------------------------------------------------------------*\
Cast: int to long
Depends on: return $E
\* ---------------------------------------------------------------------------*/
castdef<long> $E<int> {
	return LLVMBuildSExt(
		$0.codegen(parentBlock),
		LLVMInt64Type(),
		""
	);
}


/* ---------------------------------------------------------------------------*\
|                                                                              |
|                                 STRING TYPES                                 |
|                                                                              |
\* ---------------------------------------------------------------------------*/


// /* ---------------------------------------------------------------------------*\
// Name: String declaration
// Template: string $I
// \* ---------------------------------------------------------------------------*/
// stmtdef string $I {
// 	LLVMValueRef storage = LLVMBuildAlloca(LLVMPointerType(LLVMInt8Type(), 0), "");
// 	LLVMSetAlignment(storage, 1);
// 	addToScope(parentBlock, $0, string, storage);
// }

// /* ---------------------------------------------------------------------------*\
// Name: String declaration with initialization
// Template: string $I = $E<string>
// \* ---------------------------------------------------------------------------*/
// stmtdef string $I = $E<string> {
// 	LLVMValueRef storage = LLVMBuildAlloca(LLVMPointerType(LLVMInt8Type(), 0), "");
// 	LLVMSetAlignment(storage, 1);
// 	LLVMBuildStore($1.codegen(parentBlock), storage);
// 	addToScope(parentBlock, $0, string, storage);
// }


/* ---------------------------------------------------------------------------*\
|                                                                              |
|                                  MISC TYPES                                  |
|                                                                              |
\* ---------------------------------------------------------------------------*/


/* ---------------------------------------------------------------------------*\
Name: BuiltinType array declaration
Template: BuiltinType $I[$E<int>]
\* ---------------------------------------------------------------------------*/
stmtdef BuiltinType $I[$E<int>] {
	LLVMValueRef array = LLVMBuildArrayAlloca(LLVMPointerType(LLVMGetTypeByName("BuiltinType"), 0), $1.codegen(parentBlock), "");
	LLVMValueRef arrayptr = LLVMBuildAlloca(LLVMPointerType(LLVMPointerType(LLVMGetTypeByName("BuiltinType"), 0), 0), "");
	LLVMBuildStore(array, arrayptr);
	addToScope(parentBlock, $0, BuiltinTypePtr, arrayptr);
}

/* ---------------------------------------------------------------------------*\
Name: BuiltinType array element setter
Template: $E<BuiltinTypePtr>[$E<int>] = $E<BuiltinType>
\* ---------------------------------------------------------------------------*/
exprdef<BuiltinType> $E<BuiltinTypePtr>[$E<int>] = $E<BuiltinType> {
	LLVMValueRef var = $0.codegen(parentBlock);
	LLVMValueRef idx = $1.codegen(parentBlock);

	LLVMValueRef gep = LLVMBuildInBoundsGEP1(var, idx, "");

	LLVMValueRef expr = $2.codegen(parentBlock);
	LLVMBuildStore(expr, gep);
	return expr;
}

/* ---------------------------------------------------------------------------*\
Name: BuiltinType array element getter
Template: $E<BuiltinTypePtr>[$E<int>]
\* ---------------------------------------------------------------------------*/
exprdef<BuiltinType> $E<BuiltinTypePtr>[$E<int>] {
	LLVMValueRef var = $0.codegen(parentBlock);
	LLVMValueRef idx = $1.codegen(parentBlock);

	LLVMValueRef gep = LLVMBuildInBoundsGEP1(var, idx, "");
	LLVMValueRef val = LLVMBuildLoad(gep, "");
	LLVMSetAlignment(val, 8);
	return val;
}

exprdef<bool> $E<BuiltinType> == $E<BuiltinType> {
	return LLVMBuildICmp(LLVMIntEQ, $0.codegen(parentBlock), $1.codegen(parentBlock), "cmp");
}

exprdef<bool> $E<BuiltinType> != $E<BuiltinType> {
	return LLVMBuildICmp(LLVMIntNE, $0.codegen(parentBlock), $1.codegen(parentBlock), "cmp");
}

exprdef<bool> $E<BaseType> == $E<BaseType> {
	return LLVMBuildICmp(LLVMIntEQ, $0.codegen(parentBlock), $1.codegen(parentBlock), "cmp");
}

exprdef<bool> $E<BaseType> != $E<BaseType> {
	return LLVMBuildICmp(LLVMIntNE, $0.codegen(parentBlock), $1.codegen(parentBlock), "cmp");
}

/* ---------------------------------------------------------------------------*\
Cast: BuiltinType to BaseType
Depends on: return $E
\* ---------------------------------------------------------------------------*/
inhtdef<BaseType> $E<BuiltinType> {
	return LLVMBuildBitCast(
		$0.codegen(parentBlock),
		LLVMPointerType(LLVMGetTypeByName("BaseType"), 0),
		""
	);
}


/* ---------------------------------------------------------------------------*\
|                                                                              |
|                           FLOW CONTROL STATEMENTS                            |
|                                                                              |
\* ---------------------------------------------------------------------------*/


/* ---------------------------------------------------------------------------*\
Name: If statement
Template: if($E<bool>) $S
Depends on: LLVMValueRef $I = $E<LLVMValueRef>
            LLVMBasicBlockRef $I = $E<LLVMBasicBlockRef>
\* ---------------------------------------------------------------------------*/
stmtdef if($E<bool>) $S {
	LLVMValueRef ifCond = $0.codegen(parentBlock);
	LLVMBasicBlockRef ifBlock = LLVMAppendBasicBlock(function, "ifBlock");
	LLVMBasicBlockRef elseBlock = LLVMAppendBasicBlock(function, "elseBlock");
	LLVMBuildCondBr(ifCond, ifBlock, elseBlock);

	LLVMPositionBuilder(ifBlock);
	$1.codegen(parentBlock);
	LLVMBuildBr(elseBlock);

	LLVMPositionBuilder(elseBlock);
}

/* ---------------------------------------------------------------------------*\
Name: If-else statement
Template: if($E<bool>) $S else $S
Depends on: LLVMValueRef $I = $E<LLVMValueRef>
            LLVMBasicBlockRef $I = $E<LLVMBasicBlockRef>
\* ---------------------------------------------------------------------------*/
stmtdef if($E<bool>) $S else $S {
	LLVMValueRef ifCond = $0.codegen(parentBlock);
	LLVMBasicBlockRef ifBlock = LLVMAppendBasicBlock(function, "ifBlock");
	LLVMBasicBlockRef elseBlock = LLVMAppendBasicBlock(function, "elseBlock");
	LLVMBasicBlockRef endIfBlock = LLVMAppendBasicBlock(function, "endIfBlock");
	LLVMBuildCondBr(ifCond, ifBlock, elseBlock);

	LLVMPositionBuilder(ifBlock);
	$1.codegen(parentBlock);
	LLVMBuildBr(endIfBlock);

	LLVMPositionBuilder(elseBlock);
	$2.codegen(parentBlock);
	LLVMBuildBr(endIfBlock);

	LLVMPositionBuilder(endIfBlock);
}

stmtdef for(int $I = $E<int>; $E; $E) $B {
	// Inherent global scope into for block scope
	$4.parent = parentBlock;

	// Allocate loop variable
	LLVMValueRef loopVar = LLVMBuildAlloca(LLVMInt32Type(), "");
	LLVMSetAlignment(loopVar, 4);
	LLVMSetAlignment(LLVMBuildStore($1.codegen(parentBlock), loopVar), 4);
	addToScope($4, $0, int, loopVar);

	// Reresolve condition and update expressions to take loop variable into account
	resolveExprAST($4, $2);
	resolveExprAST($4, $3);

	// Create basic blocks
	LLVMBasicBlockRef forCondBlock = LLVMAppendBasicBlock(function, "forCondBlock");
	LLVMBasicBlockRef forBlock = LLVMAppendBasicBlock(function, "forBlock");
	LLVMBasicBlockRef endForBlock = LLVMAppendBasicBlock(function, "endForBlock");
	LLVMBuildBr(forCondBlock);

	// Exit for loop if condition isn't met
	LLVMPositionBuilder(forCondBlock);
	LLVMValueRef forCond = $2.codegen($4); // Codegen condition in loop block scope
	LLVMBuildCondBr(forCond, forBlock, endForBlock);

	LLVMPositionBuilder(forBlock);
	$4.codegen(parentBlock); // Codegen loop block in global scope
	$3.codegen($4); // Codegen update expression in loop block scope

	// Repeat for loop
	LLVMBuildBr(forCondBlock);

	LLVMPositionBuilder(endForBlock);
}

stmtdef while ($E<bool>) $S {
	// Create basic blocks
	LLVMBasicBlockRef whileBlock = LLVMAppendBasicBlock(function, "whileBlock");
	LLVMBasicBlockRef endWhileBlock = LLVMAppendBasicBlock(function, "endWhileBlock");

	// Skip while loop if condition isn't met
	LLVMValueRef whileCond = $0.codegen(parentBlock);
	LLVMBuildCondBr(whileCond, whileBlock, endWhileBlock);

	LLVMPositionBuilder(whileBlock);
	$1.codegen(parentBlock); // Codegen loop block

	// Repeat while loop if condition is met
	whileCond = $0.codegen(parentBlock);
	LLVMBuildCondBr(whileCond, whileBlock, endWhileBlock);

	LLVMPositionBuilder(endWhileBlock);
}


/* ---------------------------------------------------------------------------*\
|                                                                              |
|                               MISC STATEMENTS                                |
|                                                                              |
\* ---------------------------------------------------------------------------*/


/* ---------------------------------------------------------------------------*\
Name: Compile exception statement
Template: throw CompileError($E<string>, $E<ExprAST>)
\* ---------------------------------------------------------------------------*/
stmtdef throw CompileError($E<string>, $E<ExprAST>) {
	LLVMValueRef args[2];
	args[0] = $0.codegen(parentBlock);
	args[1] = $1.codegen(parentBlock);
	LLVMBuildCall(raiseCompileError, args, 2, "");
}

/* ---------------------------------------------------------------------------*\
Name: Unimplemented single-statement for-loop error
Template: for(int $I = $E<int>; $E; $E) $S
\* ---------------------------------------------------------------------------*/
stmtdef for(int $I = $E<int>; $E; $E) $S {
	throw CompileError("single-statement for-loop not supported. Use `for (...) {...}` instead!", $4);
}

/* ---------------------------------------------------------------------------*\
Name: Function declaration
Template: $E<BuiltinType> $I($E<BuiltinType> $I, ...)
\* ---------------------------------------------------------------------------*/
stmtdef $E<BuiltinType> $I($E<BuiltinType> $I, ...) {
	BuiltinType returnType = getconst($0, parentBlock);
	string funcName = $1.name;
	int numArgs = $2.size;

	BuiltinType argTypes[numArgs];
	for (int i = 0; i != numArgs; i = i + 1)
	{
		argTypes[i] = getconst($2[i], parentBlock);
	}

	defineFunction(parentBlock, funcName, returnType, argTypes, numArgs, 0);
}

/* ---------------------------------------------------------------------------*\
Name: Function declaration without parameter names
Template: $E<BuiltinType> $I($E<BuiltinType>, ...)
\* ---------------------------------------------------------------------------*/
stmtdef $E<BuiltinType> $I($E<BuiltinType>, ...) {
	BuiltinType returnType = getconst($0, parentBlock);
	string funcName = $1.name;
	int numArgs = $2.size;

	BuiltinType argTypes[numArgs];
	for (int i = 0; i != numArgs; i = i + 1)
	{
		argTypes[i] = getconst($2[i], parentBlock);
	}

	// Handle $E<BuiltinType> $I(void)
	if (numArgs == 1 && argTypes[0] == void)
		numArgs = numArgs - 1;

	defineFunction(parentBlock, funcName, returnType, argTypes, numArgs, 0);
}

/* ---------------------------------------------------------------------------*\
Name: Variable argument function declaration
Template: $E<BuiltinType> $I($E<BuiltinType> $I, ..., $V)
\* ---------------------------------------------------------------------------*/
stmtdef $E<BuiltinType> $I($E<BuiltinType> $I, ..., $V) {
	BuiltinType returnType = getconst($0, parentBlock);
	string funcName = $1.name;
	int numArgs = $2.size;

	BuiltinType argTypes[numArgs];
	for (int i = 0; i != numArgs; i = i + 1)
	{
		argTypes[i] = getconst($2[i], parentBlock);
	}

	defineFunction(parentBlock, funcName, returnType, argTypes, numArgs, 1);
}

// /* ---------------------------------------------------------------------------*\
// Name: Variable argument function declaration without parameter names
// Template: $E<BuiltinType> $I($E<BuiltinType>, ..., $V)
// TODO: This breaks!
// \* ---------------------------------------------------------------------------*/
// stmtdef $E<BuiltinType> $I($E<BuiltinType>, ..., $V) {
// 	BuiltinType returnType = getconst($0, parentBlock);
// 	string funcName = $1.name;
// 	int numArgs = $2.size;

// 	BuiltinType argTypes[numArgs];
// 	for (int i = 0; i != numArgs; i = i + 1)
// 	{
// 		argTypes[i] = getconst($2[i], parentBlock);
// 	}

// 	defineFunction(parentBlock, funcName, returnType, argTypes, numArgs, 1);
// }

/* ---------------------------------------------------------------------------*\
Name: Variable declaration
Template: $E<BuiltinType> $I
\* ---------------------------------------------------------------------------*/
stmtdef $E<BuiltinType> $I {
	long strlen(string str);

	BuiltinType type = getconst($0, parentBlock);
	string typeName = getTypeName(type);
	LLVMValueRef storage = LLVMAddGlobal(type.llvmtype, $1.name);
	LLVMSetInitializer(storage, LLVMConstNull(type.llvmtype));
	LLVMSetAlignment(storage, type.align);
	addToScope(parentBlock, $1, type, storage);

	if (dfile && type.encoding != 0)
	{
		LLVMDIBuilderInsertDeclareAtEnd(
			storage,
			LLVMDIBuilderCreateAutoVariable(
				LLVMGetSubprogram(function),
				$1.name,
				strlen($1.name),
				dfile,
				getExprLine($1),
				LLVMDIBuilderCreateBasicType(typeName, strlen(typeName), type.numbits, type.encoding, 0),
				0,
				0,
				0
			),
			LLVMDIBuilderCreateExpression(),
			LLVMDIBuilderCreateDebugLocation(getExprLine($1), getExprColumn($1), LLVMGetSubprogram(function)),
			LLVMGetInsertBlock()
		);
	}
}

/* ---------------------------------------------------------------------------*\
Name: Variable declaration with initialization
Template: $E<BuiltinType> $I = $E
\* ---------------------------------------------------------------------------*/
stmtdef $E<BuiltinType> $I = $E {
	string malloc(long size);
	string strcpy(string destination, string source);
	string strcat(string destination, string source);
	long strlen(string str);

	BuiltinType varType = getconst($0, parentBlock);
	string varTypeName = getTypeName(varType);
	BuiltinType exprType = gettype($2, parentBlock);
	ExprAST expr = $2;
	if (varType != exprType)
	{
		expr = lookupCast(parentBlock, expr, varType);
		if (!expr)
		{
			string err = malloc(256);
			strcpy(err, "cannot convert <");
			strcat(err, getTypeName(exprType));
			strcat(err, "> to <");
			strcat(err, varTypeName);
			strcat(err, "> in initialization");
			throw CompileError(err, $0);
		}
	}

	LLVMValueRef storage = LLVMAddGlobal(varType.llvmtype, $1.name);
	LLVMSetInitializer(storage, LLVMConstNull(varType.llvmtype));
	LLVMSetAlignment(storage, varType.align);
	LLVMBuildStore(expr.codegen(parentBlock), storage);
	addToScope(parentBlock, $1, varType, storage);

	if (dfile && varType.encoding != 0)
	{
		LLVMDIBuilderInsertDeclareAtEnd(
			storage,
			LLVMDIBuilderCreateAutoVariable(
				LLVMGetSubprogram(function),
				$1.name,
				strlen($1.name),
				dfile,
				getExprLine($1),
				LLVMDIBuilderCreateBasicType(varTypeName, strlen(varTypeName), varType.numbits, varType.encoding, 0),
				0,
				0,
				0
			),
			LLVMDIBuilderCreateExpression(),
			LLVMDIBuilderCreateDebugLocation(getExprLine($1), getExprColumn($1), LLVMGetSubprogram(function)),
			LLVMGetInsertBlock()
		);
	}
}

/* ---------------------------------------------------------------------------*\
Name: Variable assignment
Template: $I = $E
\* ---------------------------------------------------------------------------*/
exprdef<gettype($0, parentBlock)> $I = $E {
	string malloc(long size);
	string strcpy(string destination, string source);
	string strcat(string destination, string source);

	BaseType varType = LookupScopeType(parentBlock, $0);
	BuiltinType exprType = gettype($1, parentBlock);
	ExprAST expr = $1;
	if (varType != exprType)
	{
		expr = lookupCast(parentBlock, expr, varType);
		if (!expr)
		{
			string err = malloc(256);
			strcpy(err, "cannot convert <");
			strcat(err, getTypeName(exprType));
			strcat(err, "> to <");
			strcat(err, getTypeName(varType));
			strcat(err, "> in assignment");
			throw CompileError(err, $0);
		}
	}

	LLVMValueRef varValue = LookupScope(parentBlock, $0);
	if (!varValue)
	{
		string err = malloc(256);
		strcpy(err, "`");
		strcat(err, $0.name);
		strcat(err, "` was not declared in this scope");
		throw CompileError(err, $0);
	}

	LLVMValueRef exprValue = expr.codegen(parentBlock);
	LLVMBuildStore(exprValue, varValue);
	return exprValue;
}