import os
import re

################################################################################
# Exception classes
################################################################################

class UnknownTypeException(Exception):
    def __init__(self, typestr):
        super().__init__("Unknown type: " + typestr)
        self.typestr = typestr

################################################################################
# Regexes
################################################################################

type_regex = re.compile(r"(?:%\"[^\"]*\")|%[\w.:]+")
typedef_regex = re.compile(r"(.*?) = type (.*)")
decl_regex = re.compile(r"define [^@]+ @[^_\"].*")
decl_parts_regex = re.compile(r"define (dso_local)? (.*?) @([^(]+)\((.*)\) (?:local_unnamed_addr )?#.*")

template_regex = re.compile(r"@(\t*)(\w+)@")

################################################################################
# Globals
################################################################################

FILE_HEADER = """// This file was generated by llvm-c-decl-extractor.py.
// Do not edit this file directly!
// To edit this file, edit the template in "/llvm_constants/templates" and rerun llvm-c-decl-extractor.py.
"""

types = {}
decls = []

################################################################################
# Helper functions
################################################################################

def split_outside_brackets(sentence, seperator):
    wordstart = 0
    words = []
    bracket_level = 0
    for i, c in enumerate(sentence):
        if c == "(":
            bracket_level += 1
        elif c == ")":
            bracket_level -= 1
        elif bracket_level == 0 and i + len(seperator) <= len(sentence) and all(sentence[i + j] == sc for j, sc in enumerate(seperator)):
            words.append(sentence[wordstart:i])
            wordstart = i + len(seperator)
    if wordstart + 1 < len(sentence):
        words.append(sentence[wordstart:])
    return words

def get_name(llvmid):
    name = llvmid.lstrip('%').replace('.', '_').replace('::', '_')
    if name.startswith("struct"): name = name[len("struct"):]
    return name.strip('_')

def resolve_type(typestr):
    typestr = typestr \
        .replace("noalias", "") \
        .replace("nocapture", "") \
        .replace("nonnull", "") \
        .replace("readonly", "") \
        .replace("readnone", "") \
        .replace("zeroext", "") \
        .strip()

    rawtypestr = typestr.rstrip('*')
    ptrlevel = len(typestr) - len(rawtypestr)

    # if rawtypestr.endswith("Ref"):
    #     rawtypestr = rawtypestr[:-3]
    #     ptrlevel += 1

    if rawtypestr == 'void':
        if ptrlevel:
            typestr = "BuiltinTypes::VoidPtr"
            ptrlevel -= 1
        else:
            typestr = "BuiltinTypes::Void"
    elif rawtypestr == 'i8':
        if ptrlevel:
            typestr = "BuiltinTypes::Int8Ptr"
            ptrlevel -= 1
        else:
            typestr = "BuiltinTypes::Int8"
    elif rawtypestr == 'i16':
        if ptrlevel:
            typestr = "BuiltinTypes::Int16Ptr"
            ptrlevel -= 1
        else:
            typestr = "BuiltinTypes::Int16"
    elif rawtypestr == 'i32':
        if ptrlevel:
            typestr = "BuiltinTypes::Int32Ptr"
            ptrlevel -= 1
        else:
            typestr = "BuiltinTypes::Int32"
    elif rawtypestr == 'i64':
        if ptrlevel:
            typestr = "BuiltinTypes::Int64Ptr"
            ptrlevel -= 1
        else:
            typestr = "BuiltinTypes::Int64"
    elif rawtypestr == 'half':
        if ptrlevel:
            typestr = "BuiltinTypes::HalfPtr"
            ptrlevel -= 1
        else:
            typestr = "BuiltinTypes::Half"
    elif rawtypestr == 'float':
        if ptrlevel:
            typestr = "BuiltinTypes::FloatPtr"
            ptrlevel -= 1
        else:
            typestr = "BuiltinTypes::Float"
    elif rawtypestr == 'double':
        if ptrlevel:
            typestr = "BuiltinTypes::DoublePtr"
            ptrlevel -= 1
        else:
            typestr = "BuiltinTypes::Double"
    elif rawtypestr in types:
        typestr = get_name(rawtypestr)
        if typestr.startswith("LLVMOpaque"):
            typestr = "LLVM" + typestr[len("LLVMOpaque"):]
            if not typestr.endswith("Ref"):
                typestr += "Ref"
                ptrlevel -= 1
        typestr = "BuiltinTypes::" + typestr
    else:
        raise UnknownTypeException(typestr)

    for _ in range(ptrlevel):
        typestr += "->Ptr()"

    return typestr

################################################################################
# Parse Core.ll
################################################################################

for filename in ['Core.ll', 'DebugInfo.ll']:
    with open(filename, 'r') as file:
        for line in file:
            line = line.strip('\n')
            
            match = typedef_regex.fullmatch(line)
            if match:
                #print(match.group(1), match.group(2))
                types[match.group(1)] = [False, match.group(2)]

            if decl_regex.fullmatch(line):
                #print(line)
                decls.append(line)

num_used = sum(1 for t in types.values() if t[0])
num_unused = len(types)
print(num_used, num_unused)

# Mark all types in decls as used
for decl in decls:
    for match in type_regex.finditer(decl):
        match = match.group(0)
        types[match][0] = True

num_used = sum(1 for t in types.values() if t[0])
num_unused = len(types)
print(num_used, num_unused)

# Repeatedly mark types used by used types as used
for i in range(1):
    for t, tb in types.items():
        if tb[0] == True:
            for match in type_regex.finditer(tb[1]):
                match = match.group(0)
                types[match][0] = True

    num_used = sum(1 for t in types.values() if t[0])
    num_unused = len(types)
    print(num_used, num_unused)

types = { t: tb[1] for t, tb in types.items() if tb[0] }

print(len(decls))

for filename in os.listdir("./templates"):
    template_path = os.path.join("./templates", filename)
    if os.path.isdir(template_path): continue

    ############################################################################
    # Read template
    ############################################################################

    template = open(template_path, 'r').read()
    template_regex.fullmatch(template)

    def repl(match):
        template_indent = match.group(1)
        template_name = match.group(2)
        if template_name == "LLVM_EXTERN_FUNC_DEF":

            ####################################################################
            # Print extern function declarations
            ####################################################################

            output = []
            unknown_types = set()
            for decl in decls:
                match = decl_parts_regex.fullmatch(decl)

                d_name = get_name(match.group(3))

                try:
                    restype = resolve_type(match.group(2))
                    argtypes = [resolve_type(typestr) for typestr in split_outside_brackets(match.group(4), ", ")]
                except UnknownTypeException as err:
                    unknown_types.add(err.typestr)
                    continue

                output.append(
                    'llvm_c_functions.push_back(Func("{}", {}, {{ {} }}, false));'
                    .format(d_name, restype, ", ".join(argtypes))
                )

            # Report unknown file types
            if unknown_types:
                print(str(len(unknown_types)) + " UNKNOWN TYPES FOUND:")
                for t in unknown_types:
                    print(t)
                #raise Exception("Unknown types found")

            return template_indent + ("\n" + template_indent).join(output)

        elif template_name == "LLVM_TYPE_DECL":

            ####################################################################
            # Print type declarations
            ####################################################################

            output = []
            for t, tb in types.items():
                t_id = t[1:]
                t_name = get_name(t)
                output.append('StructType* {};'.format(t_name, t_id))
            return template_indent + ("\n" + template_indent).join(output)

        elif template_name == "LLVM_TYPE_EXTERN_DECL":

            ####################################################################
            # Print extern type declarations
            ####################################################################

            output = []
            for t, tb in types.items():
                t_id = t[1:]
                t_name = get_name(t)
                output.append('extern StructType* {};'.format(t_name, t_id))
            return template_indent + ("\n" + template_indent).join(output)

        elif template_name == "LLVM_TYPE_DEF":

            ####################################################################
            # Print type definitions
            ####################################################################

            output = []
            for t, tb in types.items():
                t_id = t[1:]
                t_name = get_name(t)
                output.append('{} = StructType::create(c, "{}");'.format(t_name, t_id))
            return template_indent + ("\n" + template_indent).join(output)

    template = template_regex.sub(repl, template)

    ############################################################################
    # Write output
    ############################################################################

    output_path = os.path.join("../src", filename)
    with open(output_path, 'w') as out:
        out.write(FILE_HEADER)
        out.write(template)
