import os
import re

################################################################################
# Classes
################################################################################

class UnknownTypeException(Exception):
    def __init__(self, typestr):
        super().__init__("Unknown type: " + typestr)
        self.typestr = typestr

class FuncDecl(object):
    def __init__(self, attrs, restype, name, argtypes):
        self.attrs = attrs
        self.restype = restype
        self.name = name
        self.argtypes = argtypes
        self.modified_name = None

################################################################################
# Regexes
################################################################################

type_regex = re.compile(r"(?:%\"[^\"]*\")|%[\w.:]+")
typedef_regex = re.compile(r"(.*?) = type (.*)")
decl_parts_regex = re.compile(r"define (dso_local)? (.*?) @([^(]+)\((.*)\) (?:local_unnamed_addr )?#.*")

template_regex = re.compile(r"@(\t*)(\w+)@")

################################################################################
# Globals
################################################################################

FILE_HEADER = """// This file was generated by llvm-c-decl-extractor.py.
// Do not edit this file directly!
// To edit this file, edit the template in "/llvm_constants/templates" and rerun llvm-c-decl-extractor.py.
"""

types = {}
decls = []

################################################################################
# Helper functions
################################################################################

def split_outside_brackets(sentence, seperator):
    wordstart = 0
    words = []
    bracket_level = 0
    for i, c in enumerate(sentence):
        if c == "(":
            bracket_level += 1
        elif c == ")":
            bracket_level -= 1
        elif bracket_level == 0 and i + len(seperator) <= len(sentence) and all(sentence[i + j] == sc for j, sc in enumerate(seperator)):
            words.append(sentence[wordstart:i])
            wordstart = i + len(seperator)
    if wordstart + 1 < len(sentence):
        words.append(sentence[wordstart:])
    return words

def get_name(llvmid):
    name = llvmid.lstrip('%').replace('.', '_').replace('::', '_')
    if name.startswith("struct"): name = name[len("struct"):]
    return name.strip('_')

def get_builtin_type(typestr):
    typestr = typestr \
        .replace("noalias", "") \
        .replace("nocapture", "") \
        .replace("nonnull", "") \
        .replace("readonly", "") \
        .replace("readnone", "") \
        .replace("zeroext", "") \
        .strip()

    rawtypestr = typestr.rstrip('*')
    ptrlevel = len(typestr) - len(rawtypestr)

    # if rawtypestr.endswith("Ref"):
    #     rawtypestr = rawtypestr[:-3]
    #     ptrlevel += 1

    if rawtypestr == 'void':
        if ptrlevel:
            typestr = "BuiltinTypes::VoidPtr"
            ptrlevel -= 1
        else:
            typestr = "BuiltinTypes::Void"
    elif rawtypestr == 'i8':
        if ptrlevel:
            typestr = "BuiltinTypes::Int8Ptr"
            ptrlevel -= 1
        else:
            typestr = "BuiltinTypes::Int8"
    elif rawtypestr == 'i16':
        if ptrlevel:
            typestr = "BuiltinTypes::Int16Ptr"
            ptrlevel -= 1
        else:
            typestr = "BuiltinTypes::Int16"
    elif rawtypestr == 'i32':
        if ptrlevel:
            typestr = "BuiltinTypes::Int32Ptr"
            ptrlevel -= 1
        else:
            typestr = "BuiltinTypes::Int32"
    elif rawtypestr == 'i64':
        if ptrlevel:
            typestr = "BuiltinTypes::Int64Ptr"
            ptrlevel -= 1
        else:
            typestr = "BuiltinTypes::Int64"
    elif rawtypestr == 'half':
        if ptrlevel:
            typestr = "BuiltinTypes::HalfPtr"
            ptrlevel -= 1
        else:
            typestr = "BuiltinTypes::Half"
    elif rawtypestr == 'float':
        if ptrlevel:
            typestr = "BuiltinTypes::FloatPtr"
            ptrlevel -= 1
        else:
            typestr = "BuiltinTypes::Float"
    elif rawtypestr == 'double':
        if ptrlevel:
            typestr = "BuiltinTypes::DoublePtr"
            ptrlevel -= 1
        else:
            typestr = "BuiltinTypes::Double"
    elif rawtypestr in types:
        typestr = get_name(rawtypestr)
        if typestr.startswith("LLVMOpaque"):
            typestr = "LLVM" + typestr[len("LLVMOpaque"):]
            if not typestr.endswith("Ref"):
                typestr += "Ref"
                ptrlevel -= 1
        typestr = "BuiltinTypes::" + typestr
    else:
        raise UnknownTypeException(typestr)

    for _ in range(ptrlevel):
        typestr += "->Ptr()"

    return typestr

def get_c_type(typestr):
    typestr = typestr \
        .replace("noalias", "") \
        .replace("nocapture", "") \
        .replace("nonnull", "") \
        .replace("readonly", "") \
        .replace("readnone", "") \
        .replace("zeroext", "") \
        .strip()

    typestr = get_name(typestr)

    rawtypestr = typestr.rstrip('*')
    ptrs = typestr[len(rawtypestr):]

    if typestr == 'i8*':
        typestr = 'const char*'
    elif rawtypestr == 'i8':
        typestr = 'int8_t' + ptrs
    elif rawtypestr == 'i16':
        typestr = 'int16_t' + ptrs
    elif rawtypestr == 'i32':
        typestr = 'int32_t' + ptrs
    elif rawtypestr == 'i64':
        typestr = 'int64_t' + ptrs

    return typestr

################################################################################
# Parse Core.ll
################################################################################

for filename in ['Core.ll', 'DebugInfo.ll']:
    with open(filename, 'r') as file:
        for line in file:
            line = line.strip('\n')
            
            match = typedef_regex.fullmatch(line)
            if match:
                #print(match.group(1), match.group(2))
                types[match.group(1)] = [False, match.group(2)]

            match = decl_parts_regex.fullmatch(line)
            if match and not match.group(3).startswith('_'): # Ignore C++ functions starting with '_'
                decl = FuncDecl(*match.groups())
                decl.name = get_name(decl.name)
                decl.argtypes = split_outside_brackets(decl.argtypes, ", ")
                decls.append(decl)

num_used = sum(1 for t in types.values() if t[0])
num_unused = len(types)
print(num_used, num_unused)

# Mark all types in decls as used
for decl in decls:
    for tpe in [decl.restype] + decl.argtypes:
        match = type_regex.search(tpe)
        if match:
            match = match.group(0)
            types[match][0] = True

num_used = sum(1 for t in types.values() if t[0])
num_unused = len(types)
print(num_used, num_unused)

# Repeatedly mark types used by used types as used
for i in range(1):
    for t, tb in types.items():
        if tb[0] == True:
            for match in type_regex.finditer(tb[1]):
                match = match.group(0)
                types[match][0] = True

    num_used = sum(1 for t in types.values() if t[0])
    num_unused = len(types)
    print(num_used, num_unused)

types = { t: tb[1] for t, tb in types.items() if tb[0] }

print(len(decls))

################################################################################
# Modify functions
################################################################################

REPLACE_PARAMS = {
    '%struct.LLVMOpaqueBuilder*': 'wrap(builder)',
    '%struct.LLVMOpaqueModule*': 'wrap(currentModule)',
    '%struct.LLVMOpaqueDIBuilder*': 'wrap(dbuilder)',
}
for decl in decls:
    for argtype in decl.argtypes:
        if argtype in REPLACE_PARAMS:
            decl.modified_name = "LLVMEX" + decl.name[4:]
            break

for filename in os.listdir("./templates"):
    template_path = os.path.join("./templates", filename)
    if os.path.isdir(template_path): continue

    ############################################################################
    # Read template
    ############################################################################

    template = open(template_path, 'r').read()
    template_regex.fullmatch(template)

    def repl(match):
        template_indent = match.group(1)
        template_name = match.group(2)
        if template_name == "LLVM_EXTERN_FUNC_DEF":

            ####################################################################
            # Print extern function declarations
            ####################################################################

            output = []
            unknown_types = set()
            for decl in decls:
                try:
                    restype = get_builtin_type(decl.restype)
                    argtypes = [get_builtin_type(typestr) for typestr in decl.argtypes if typestr not in REPLACE_PARAMS]
                except UnknownTypeException as err:
                    unknown_types.add(err.typestr)
                    continue

                output.append(
                    'llvm_c_functions.push_back(Func("{}", {}, {{ {} }}, false{}));'
                    .format(
                        decl.name,
                        restype,
                        ", ".join(argtypes),
                        ', "{}"'.format(decl.modified_name) if decl.modified_name else ""
                    )
                )

            # Report unknown file types
            if unknown_types:
                print(str(len(unknown_types)) + " UNKNOWN TYPES FOUND:")
                for t in unknown_types:
                    print(t)
                #raise Exception("Unknown types found")

            return template_indent + ("\n" + template_indent).join(output)

        elif template_name == "LLVM_TYPE_DECL":

            ####################################################################
            # Print type declarations
            ####################################################################

            output = []
            for t, tb in types.items():
                t_id = t[1:]
                t_name = get_name(t)
                output.append('StructType* {};'.format(t_name, t_id))
            return template_indent + ("\n" + template_indent).join(output)

        elif template_name == "LLVM_TYPE_EXTERN_DECL":

            ####################################################################
            # Print extern type declarations
            ####################################################################

            output = []
            for t, tb in types.items():
                t_id = t[1:]
                t_name = get_name(t)
                output.append('extern StructType* {};'.format(t_name, t_id))
            return template_indent + ("\n" + template_indent).join(output)

        elif template_name == "LLVM_TYPE_DEF":

            ####################################################################
            # Print type definitions
            ####################################################################

            output = []
            for t, tb in types.items():
                t_id = t[1:]
                t_name = get_name(t)
                output.append('{} = StructType::create(c, "{}");'.format(t_name, t_id))
            return template_indent + ("\n" + template_indent).join(output)

        elif template_name == "MODIFIED_LLVM_EXTERN_FUNC_DEF":

            ####################################################################
            # Print modified extern functions
            ####################################################################

            output = []
            for decl in decls:
                if decl.modified_name:
                    restype = get_c_type(decl.restype)

                    args = []
                    argvals = []
                    for i, typestr in enumerate(decl.argtypes):
                        argval = REPLACE_PARAMS.get(typestr)
                        if argval is None:
                            argval = '_' + str(i)
                            args.append(get_c_type(typestr) + ' ' + argval)
                        argvals.append(argval)

                    output.append(
                        '{} {}({}) {{ return {}({}); }}'
                        .format(
                            restype,
                            decl.modified_name,
                            ", ".join(args),
                            decl.name,
                            ", ".join(argvals)
                        )
                    )

            return template_indent + ("\n" + template_indent).join(output)

    template = template_regex.sub(repl, template)

    ############################################################################
    # Write output
    ############################################################################

    output_path = os.path.join("../src", filename)
    with open(output_path, 'w') as out:
        out.write(FILE_HEADER)
        out.write(template)
