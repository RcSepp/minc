APP_NAME = p"minc";
HELP_MESSAGE = p"minc compiler\n";
COMMANDS = map(
	p"build": p"compile to executable",
	p"run": p"compile and run",
	p"parse": p"compile to LLVM IR",
	p"debug": p"compile LLVM IR and binary"
);

if (!COMMANDS.contains($1))
{
	print(HELP_MESSAGE);
	print(p"Usage:");
	print(p"    " + APP_NAME + p" [arguments]");
	print();
	print(p"The commands are:");
	print();
	for (cmd, desc: COMMANDS) {
		print(p"    " + cmd + (8p - cmd.length) * p" " + desc);
	}
	return 0p;
}
command = $1;

sourcePath = $2 != NULL ? $2 : p"-";
outputPath = $2;
outputPath = outputPath.substr(max(outputPath.rfind(p"/"), outputPath.rfind(p"\\")) + 1p);
dt = outputPath.rfind(p".");
if (dt != -1p) outputPath = outputPath.substr(0p, dt);
outputDebugSymbols = 1p;

PAWS_EXT = p".minc";
sourceIsPaws = sourcePath.length >= PAWS_EXT.length && sourcePath.substr(sourcePath.length - PAWS_EXT.length) == PAWS_EXT;
PY_EXT = p".py";
sourceIsPython = sourcePath.length >= PY_EXT.length && sourcePath.substr(sourcePath.length - PY_EXT.length) == PY_EXT;

// Get absolute path to source file
realPath = sourcePath == p"-" ? sourcePath : realpath(sourcePath);

// Parse source code from file or stdin into AST
if (!sourceIsPython)
	rootBlock = parseCFile(realPath);
else
	rootBlock = parsePythonFile(realPath);
if (rootBlock == NULL)
	return -1p;

// Print AST
//print(str(rootBlock));

// Compile AST
initCompiler();
initBuiltinSymbols();
module = createModule(realPath, outputDebugSymbols);
defineBuiltinSymbols(rootBlock);
print(456p);
rootBlock.codegen(NULL);
module.finalize();

// Execute command
if (command == p"parse" || command == p"debug")
{
	if (outputPath == p"-")
		module.print();
	else
		module.print(outputPath + p".ll");
}
if (command == p"build")
{
	errstr = p"";
	if (!module.compile(outputPath + p".o", errstr))
	{
		printerr(errstr);
		return -1p;
	}
}
if (command == p"run" || command == p"debug")
{
	module.run();
}

// rootBlock.exprs; // TODO
// // TODO:
// // See paws.cpp:571
// // rootBlock.exprs could return either a map<string, CodegenContext> or a map<ExprAST*, CodegenContext>
// // The goal would be to replace `exprdef p"..." { ... }` with `rootBlock.exprs[p""] = { ... }`
// //
// // Example:
// rootBlock.exprs[p"if ($E) $S"] = {
// 	if (codegen($0, parentBlock)) {
// 		codegen($1, parentBlock);
// 	}
// }
// print(rootBlock.exprs); // { p"if ($E) $S": ... }
// rootBlock.remove(p"if ($E) $S");
// print(rootBlock.exprs); // { }