APP_NAME = p"minc";
HELP_MESSAGE = p"minc compiler\n";
COMMANDS = map(
	p"build": p"compile to executable",
	p"run": p"compile and run",
	p"parse": p"compile to LLVM IR",
	p"debug": p"compile LLVM IR and binary"
);

if (!COMMANDS.contains($1))
{
	print(HELP_MESSAGE);
	print(p"Usage:");
	print(p"    " + APP_NAME + p" [arguments]");
	print();
	print(p"The commands are:");
	print();
	for (cmd, desc: COMMANDS) {
		print(p"    " + cmd + (8p - cmd.length) * p" " + desc);
	}
	return 0p;
}
command = $1;

sourcePath = $2 != NULL ? $2 : p"-";
outputPath = $2;
outputPath = outputPath.substr(max(outputPath.rfind(p"/"), outputPath.rfind(p"\\")) + 1p);
dt = outputPath.rfind(p".");
if (dt != -1p) outputPath = outputPath.substr(0p, dt);
outputDebugSymbols = 1p;

PAWS_EXT = p".minc";
sourceIsPaws = sourcePath.length >= PAWS_EXT.length && sourcePath.substr(sourcePath.length - PAWS_EXT.length) == PAWS_EXT;
PY_EXT = p".py";
sourceIsPython = sourcePath.length >= PY_EXT.length && sourcePath.substr(sourcePath.length - PY_EXT.length) == PY_EXT;

// Get absolute path to source file
realPath = sourcePath == p"-" ? sourcePath : realpath(sourcePath);

// Parse source code from file or stdin into AST
if (!sourceIsPython)
	rootBlock = parseCFile(realPath);
else
	rootBlock = parsePythonFile(realPath);
if (rootBlock == NULL)
	return -1p;

// Print AST
//print(str(rootBlock));

// Define import statement
rootBlock.stmts[import $E<PawsString>] = {
	importPath = $0.codegen(parentBlock);
	importRealPath = realpath(importPath);
	importPath = importPath.substr(max(importPath.rfind(p"/"), importPath.rfind(p"\\")) + 1p);
	dt = importPath.rfind(p".");
	if (dt != -1p) importPath = importPath.substr(0p, dt);

	// Parse imported source code //TODO: Implement file caching
	importBlock = parseCFile(importRealPath);

	// Codegen imported module
	importModule = createModule(importRealPath, importPath + p":main", outputDebugSymbols);
	importBlock.scopeType = FILE_SCOPE_TYPE;
	importBlock.symbols[FILE_SCOPE] = importBlock;
	importBlock.codegen(parentBlock);
	importModule.finalize();

	// Codegen a call to the imported module's main function
	importModule.buildRun();

	// Import imported module into importing scope
	parentBlock.import(importBlock);

	// Execute command on imported module
	if (command == p"parse" || command == p"debug")
		importModule.print(importPath + p".ll");
	if (command == p"build")
	{
		errstr = p"";
		if (!importModule.compile(importPath + p".o", errstr))
			printerr(errstr);
	}
};

// Define library import statement
rootBlock.stmts[import <$I.$I>] = {
	importPath = p"../lib/" + $0.name + p"." + $1.name;
	importRealPath = realpath(importPath);
	importPath = importPath.substr(max(importPath.rfind(p"/"), importPath.rfind(p"\\")) + 1p);
	dt = importPath.rfind(p".");
	if (dt != -1p) importPath = importPath.substr(0p, dt);

	// Parse imported source code //TODO: Implement file caching
	importBlock = parseCFile(importRealPath);

	// Codegen imported module
	importModule = createModule(importRealPath, importPath + p":main", outputDebugSymbols);
	importBlock.scopeType = FILE_SCOPE_TYPE;
	importBlock.symbols[FILE_SCOPE] = importBlock;
	importBlock.codegen(parentBlock);
	importModule.finalize();

	// Codegen a call to the imported module's main function
	importModule.buildRun();

	// Import imported module into importing scope
	parentBlock.import(importBlock);

	// Execute command on imported module
	if (command == p"parse" || command == p"debug")
		importModule.print(importPath + p".ll");
	if (command == p"build")
	{
		errstr = p"";
		if (!importModule.compile(importPath + p".o", errstr))
			printerr(errstr);
	}
};

// Compile AST
initCompiler();
initBuiltinSymbols();
module = createModule(realPath, p"main", outputDebugSymbols);
rootBlock.scopeType = FILE_SCOPE_TYPE;
defineBuiltinSymbols(rootBlock);
rootBlock.symbols[FILE_SCOPE] = rootBlock;
rootBlock.codegen(FILE_SCOPE);
module.finalize();

// Execute command
if (command == p"parse" || command == p"debug")
{
	if (outputPath == p"-")
		module.print();
	else
		module.print(outputPath + p".ll");
}
if (command == p"build")
{
	errstr = p"";
	if (!module.compile(outputPath + p".o", errstr))
	{
		printerr(errstr);
		return -1p;
	}
}
if (command == p"run" || command == p"debug")
{
	result = module.run();
	print(p"./minc Result: " + str(result));
}