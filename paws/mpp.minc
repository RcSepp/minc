APP_NAME = "minc";
HELP_MESSAGE = "minc compiler\n";
COMMANDS = map(
	"build": "compile to executable",
	"run": "compile and run",
	"parse": "compile to LLVM IR",
	"debug": "compile LLVM IR and binary"
);

if (!COMMANDS.contains($1))
{
	print(HELP_MESSAGE);
	print("Usage:");
	print("    " + APP_NAME + " [arguments]");
	print();
	print("The commands are:");
	print();
	for (cmd, desc: COMMANDS) {
		print("    " + cmd + (8 - cmd.length) * " " + desc);
	}
	return 0;
}
command = $1;

sourcePath = $2 != NULL ? $2 : "-";
outputPath = $2;
outputPath = outputPath.substr(max(outputPath.rfind("/"), outputPath.rfind("\\")) + 1);
dt = outputPath.rfind(".");
if (dt != -1) outputPath = outputPath.substr(0, dt);
outputDebugSymbols = 1;

PAWS_EXT = ".minc";
sourceIsPaws = sourcePath.length >= PAWS_EXT.length && sourcePath.substr(sourcePath.length - PAWS_EXT.length) == PAWS_EXT;
PY_EXT = ".py";
sourceIsPython = sourcePath.length >= PY_EXT.length && sourcePath.substr(sourcePath.length - PY_EXT.length) == PY_EXT;

// Get absolute path to source file
realPath = sourcePath == "-" ? sourcePath : realpath(sourcePath);

// Parse source code from file or stdin into AST
if (!sourceIsPython)
	rootBlock = parseCFile(realPath);
else
	rootBlock = parsePythonFile(realPath);
if (rootBlock == NULL)
	return -1;

// Print AST
//print(str(rootBlock));

// Define import statement
rootBlock.stmts[import $E<PawsString>] = {
	importPath = $0.codegen(parentBlock);
	importRealPath = realpath(importPath);
	importPath = importPath.substr(max(importPath.rfind("/"), importPath.rfind("\\")) + 1);
	dt = importPath.rfind(".");
	if (dt != -1) importPath = importPath.substr(0, dt);

	// Parse imported source code //TODO: Implement file caching
	importBlock = parseCFile(importRealPath);

	// Codegen imported module
	importModule = createModule(importRealPath, importPath + ":main", outputDebugSymbols);
	importBlock.scopeType = FILE_SCOPE_TYPE;
	importBlock.symbols[FILE_SCOPE] = importBlock;
	importBlock.codegen(parentBlock);
	importModule.finalize();

	// Codegen a call to the imported module's main function
	importModule.buildRun();

	// Import imported module into importing scope
	parentBlock.import(importBlock);

	// Execute command on imported module
	if (command == "parse" || command == "debug")
		importModule.print(importPath + ".ll");
	if (command == "build")
	{
		errstr = "";
		if (!importModule.compile(importPath + ".o", errstr))
			printerr(errstr);
	}
};

// Define library import statement
rootBlock.stmts[import <$I.$I>] = {
	importPath = "../lib/" + $0.name + "." + $1.name;
	importRealPath = realpath(importPath);
	importPath = importPath.substr(max(importPath.rfind("/"), importPath.rfind("\\")) + 1);
	dt = importPath.rfind(".");
	if (dt != -1) importPath = importPath.substr(0, dt);

	// Parse imported source code //TODO: Implement file caching
	importBlock = parseCFile(importRealPath);

	// Codegen imported module
	importModule = createModule(importRealPath, importPath + ":main", outputDebugSymbols);
	importBlock.scopeType = FILE_SCOPE_TYPE;
	importBlock.symbols[FILE_SCOPE] = importBlock;
	importBlock.codegen(parentBlock);
	importModule.finalize();

	// Codegen a call to the imported module's main function
	importModule.buildRun();

	// Import imported module into importing scope
	parentBlock.import(importBlock);

	// Execute command on imported module
	if (command == "parse" || command == "debug")
		importModule.print(importPath + ".ll");
	if (command == "build")
	{
		errstr = "";
		if (!importModule.compile(importPath + ".o", errstr))
			printerr(errstr);
	}
};

// Compile AST
initCompiler();
initBuiltinSymbols();
module = createModule(realPath, "main", outputDebugSymbols);
rootBlock.scopeType = FILE_SCOPE_TYPE;
defineBuiltinSymbols(rootBlock);
rootBlock.symbols[FILE_SCOPE] = rootBlock;
rootBlock.codegen(FILE_SCOPE);
module.finalize();

// Execute command
if (command == "parse" || command == "debug")
{
	if (outputPath == "-")
		module.print();
	else
		module.print(outputPath + ".ll");
}
if (command == "build")
{
	errstr = "";
	if (!module.compile(outputPath + ".o", errstr))
	{
		printerr(errstr);
		return -1;
	}
}
if (command == "run" || command == "debug")
{
	result = module.run();
	print("./minc Result: " + str(result));
}