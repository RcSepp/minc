APP_NAME = p"minc";
HELP_MESSAGE = p"minc compiler\n";
COMMANDS = map(
	p"build": p"compile to executable",
	p"run": p"compile and run",
	p"parse": p"compile to LLVM IR",
	p"debug": p"compile LLVM IR and binary"
);

if (!COMMANDS.contains($1))
{
	print(HELP_MESSAGE);
	print(p"Usage:");
	print(p"    " + APP_NAME + p" [arguments]");
	print();
	print(p"The commands are:");
	print();
	for (cmd, desc: COMMANDS) {
		print(p"    " + cmd + (8p - cmd.length) * p" " + desc);
	}
	return 0p;
}
command = $1;

sourcePath = $2 != NULL ? $2 : p"-";
outputPath = $2;
outputPath = outputPath.substr(max(outputPath.rfind(p"/"), outputPath.rfind(p"\\")) + 1p);
dt = outputPath.rfind(p".");
if (dt != -1p) outputPath = outputPath.substr(0p, dt);
outputDebugSymbols = 1p;

PAWS_EXT = p".minc";
sourceIsPaws = sourcePath.length >= PAWS_EXT.length && sourcePath.substr(sourcePath.length - PAWS_EXT.length) == PAWS_EXT;
PY_EXT = p".py";
sourceIsPython = sourcePath.length >= PY_EXT.length && sourcePath.substr(sourcePath.length - PY_EXT.length) == PY_EXT;

// Get absolute path to source file
realPath = sourcePath == p"-" ? sourcePath : realpath(sourcePath);

// Parse source code from file or stdin into AST
if (!sourceIsPython)
	rootBlock = parseCFile(realPath);
else
	rootBlock = parsePythonFile(realPath);
if (rootBlock == NULL)
	return -1p;

// Print AST
//print(str(rootBlock));

// Compile AST
initCompiler();
initBuiltinSymbols();
module = createModule(realPath, outputDebugSymbols);
defineBuiltinSymbols(rootBlock);
rootBlock.codegen(NULL);
module.finalize();

// Execute command
if (command == p"parse" || command == p"debug")
{
	if (outputPath == p"-")
		module.print();
	else
		module.print(outputPath + p".ll");
}
if (command == p"build")
{
	errstr = p"";
	if (!module.compile(outputPath + p".o", errstr))
	{
		printerr(errstr);
		return -1p;
	}
}
if (command == p"run" || command == p"debug")
{
	result = module.run();
	print(p"./minc Result: " + str(result));
}